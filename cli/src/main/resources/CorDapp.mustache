package {{PackageName}}

import co.paralleluniverse.fibers.Suspendable
import net.corda.core.contracts.*
import net.corda.core.flows.*
import net.corda.core.identity.Party
import net.corda.core.transactions.LedgerTransaction
import net.corda.core.transactions.SignedTransaction
import net.corda.core.transactions.TransactionBuilder
import net.corda.core.utilities.ProgressTracker

// Flow.
@InitiatingFlow
@StartableByRPC
class {{CorDappName}}Flow(val target: Party) : FlowLogic<SignedTransaction>() {

    override val progressTracker: ProgressTracker = {{CorDappName}}Flow.tracker()

    companion object {
    object CREATING : ProgressTracker.Step("Creating a new {{CorDappName}}!")
    object SIGNING : ProgressTracker.Step("Verifying the {{CorDappName}}!")
    object VERIFYING : ProgressTracker.Step("Verifying the {{CorDappName}}!")
    object FINALISING : ProgressTracker.Step("Sending the {{CorDappName}}!") {
    override fun childProgressTracker() = FinalityFlow.tracker()
    }

    fun tracker() = ProgressTracker(CREATING, SIGNING, VERIFYING, FINALISING)
    }

    @Suspendable
    override fun call(): SignedTransaction {
    progressTracker.currentStep = CREATING

    val me = serviceHub.myInfo.legalIdentities.first()
    val notary = serviceHub.networkMapCache.notaryIdentities.single()
    val command = Command({{CorDappName}}Contract.Send(), listOf(me.owningKey))
    val state = {{CorDappName}}State(me, target)
    val stateAndContract = StateAndContract(state, {{CorDappName}}Contract.ID)
    val utx = TransactionBuilder(notary = notary).withItems(stateAndContract, command)

    progressTracker.currentStep = SIGNING
    val stx = serviceHub.signInitialTransaction(utx)

    progressTracker.currentStep = VERIFYING
    stx.verify(serviceHub)

    progressTracker.currentStep = FINALISING
    val targetSession = initiateFlow(target)
    return subFlow(FinalityFlow(stx, listOf(targetSession), FINALISING.childProgressTracker()))
    }
    }

    @InitiatedBy({{CorDappName}}Flow::class)
    class {{CorDappName}}FlowResponder(val counterpartySession: FlowSession) : FlowLogic<SignedTransaction>() {
        @Suspendable
        override fun call(): SignedTransaction {
        return subFlow(ReceiveFinalityFlow(counterpartySession))
        }
        }

        // Contract and state.
        class {{CorDappName}}Contract: Contract {
        companion object {
        // Used to identify our contract when building a transaction.
        const val ID = "net.corda.{{CorDappName}}.{{CorDappName}}Contract"
        }

        // Command.
        class Send : TypeOnlyCommandData()

        // Contract code.
        override fun verify(tx: LedgerTransaction) = requireThat {
        val command = tx.commands.requireSingleCommand<Send>()
            "There can be no inputs when {{CorDappName}}'ing other parties." using (tx.inputs.isEmpty())
            "There must be one output: The {{CorDappName}}!" using (tx.outputs.size == 1)
            val {{#lowercase}}{{CorDappName}}{{/lowercase}} = tx.outputsOfType<{{CorDappName}}State>().single()
                "No sending {{CorDappName}}'s to {{CorDappName}}urself!" using ({{#lowercase}}{{CorDappName}}{{/lowercase}}.target != {{#lowercase}}{{CorDappName}}{{/lowercase}}.origin)
                "The {{CorDappName}}! must be signed by the sender." using ({{#lowercase}}{{CorDappName}}{{/lowercase}}.origin.owningKey == command.signers.single())
                }
                }

                // State.
                @BelongsToContract({{CorDappName}}Contract::class)
                data class {{CorDappName}}State(val origin: Party,
                val target: Party,
                val {{#lowercase}}{{CorDappName}}{{/lowercase}}: String = "{{CorDappName}}!") : ContractState {
                override val participants = listOf(target)
                override fun toString() = "${origin.name}: ${{#lowercase}}{{CorDappName}}{{/lowercase}}"
                }
